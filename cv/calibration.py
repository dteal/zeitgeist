#!/usr/bin/python3
"""
This program calculates calibration constants for the Kinect.

Conclusion:

actual distance (in meters) is
1 / (3.16913315e+00 - 2.90157634e-03 * value)
"""

"""
21.5 - 461
23 - 471

44 in wide at 47 in from sensor
52              54.5
58              59
"""

import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit

# distance (in), reading
data = np.array([[19, 400], [20, 445], [21, 450], [22, 480], [23, 515], [24, 528], [25, 550], [26, 564], [27, 579], [28, 597], [29, 616], [30, 639], [31, 653], [32, 664], [33, 671], [34, 682], [35, 701], [36, 710], [37, 715], [38, 725], [39, 736], [40, 746], [41, 757], [42, 764], [43, 771], [44, 777], [45, 786], [46, 792], [47, 799], [48, 804], [49, 810], [50, 817], [51, 822], [52, 828], [53, 834], [54, 839], [55, 842], [56, 847], [57, 851], [58, 856], [59, 860], [60, 863], [61, 866], [62, 869], [63, 874], [64, 878], [65, 881], [66, 885], [67, 887], [68, 890], [69, 893], [70, 895], [71, 897], [72, 900], [73, 903], [74, 905], [75, 909], [76, 910], [77, 913], [78, 915], [79, 917], [80, 920], [81, 922], [82, 934], [83, 926], [84, 928], [85, 930], [86, 932], [87, 934], [88, 936], [89, 937], [90, 939], [91, 941], [92, 942], [93, 944], [94, 945], [95, 946], [96, 948], [97, 949], [98, 951], [99, 953], [100, 954], [101, 956], [102, 957], [103, 958], [104, 960], [105, 961], [106, 962], [107, 963], [108, 965], [109, 966], [110, 967], [111, 968], [112, 969], [113, 970], [114, 972], [115, 972], [116, 973], [117, 974], [118, 975], [119, 976], [120, 977], [121, 978], [122, 979], [123, 980], [124, 981], [125, 982], [126, 983], [127, 984], [128, 985], [129, 985], [130, 986], [131, 987], [132, 988], [133, 989], [134, 989], [135, 990], [136, 991], [137, 992], [138, 992], [139, 993], [140, 993], [141, 994], [142, 995], [143, 996], [144, 997], [145, 997], [146, 998], [147, 998], [148, 999], [149, 1000], [150, 1000], [151, 1001], [152, 1001], [153, 1002], [154, 1002], [155, 1004], [156, 1004], [157, 1005], [158, 1005], [159, 1005], [160, 1006], [161, 1006], [162, 1007], [163, 1008], [164, 1008], [165, 1009], [166, 1009], [167, 1010], [168, 1010], [169, 1010], [170, 1011], [171, 1012], [172, 1012], [173, 1013], [174, 1013], [175, 1013], [176, 1014], [177, 1014], [178, 1015], [179, 1015], [180, 1016], [181, 1016], [182, 1016], [183, 1017], [184, 1017], [185, 1018], [186, 1018], [187, 1018], [188, 1019], [189, 1019], [190, 1020], [191, 1020], [192, 1020], [193, 1021], [194, 1021], [195, 1021], [196, 1022], [197, 1022], [198, 1023], [199, 1023], [200, 1024], [201, 1024], [204, 1025], [216, 1028], [228, 1032], [240, 1034], [252, 1038]])

def exponential(x, a, b, c, d):
    return a*np.exp(b-c*x)+d
def power(x, a, b, c, d, e):
    return e*x**4+d*x**3+c*x**2+b*x+a
def inverse(x, b, m):
    return 1/(b+m*x)

# kinect measurements
kinect = data[:,1]
# actual distance in in
distances = data[:,0] * 0.025 # convert in to m
# exponential fit
expopt, _ = curve_fit(exponential, kinect, distances, (.0003, -.2, -.5118, 34))
#expcurve = exponential(kinect, *expopt)
powopt, _ = curve_fit(power, kinect, distances, (50, 1, 1, 1, 1))
powcurve = power(kinect, *powopt)
invopt, _ = curve_fit(inverse, kinect, distances, (3.169, -0.00290))
invcurve = inverse(kinect, *invopt)

plt.plot(kinect, distances, label='measurements')
#plt.plot(kinect, expcurve, label='exponential fit')
plt.plot(kinect, powcurve, label='power fit')
plt.plot(kinect, invcurve, label='inverse fit')
plt.xlabel('Kinect depth value (unitless)')
plt.ylabel('Distance (m)')
plt.title('Kinect calibration curve')
plt.legend()
plt.show()
